#include <unistd.h>
#include "ed247.h"
#include "traces.h"
#include "sync.h"
#include <unordered_set>

#define ECIC EC_ROOT "ECIC.xml"

int main() {
  SAY(VERSION);

  SAY("Load ECIC " ECIC);
  ed247_context_t ed247_context;
  ASSERT(ed247_load_file(ECIC, &ed247_context) == ED247_STATUS_SUCCESS);

  // The ED247 protocol define "true" as a byte with all bits at one.
  // The ED247 library doesn't check the value: it only read/write the data provided by the user.
  uint8_t dis_true = 255;
  uint8_t dis_false = 0;

  // Get references to our signals from the context
  ed247_signal_t dis_signal1;
  ed247_signal_t dis_signal2;
  ed247_signal_t dis_signal3;
  ASSERT(ed247_get_signal(ed247_context, "DIS_SIGNAL1", &dis_signal1) == ED247_STATUS_SUCCESS);
  ASSERT(ed247_get_signal(ed247_context, "DIS_SIGNAL2", &dis_signal2) == ED247_STATUS_SUCCESS);
  ASSERT(ed247_get_signal(ed247_context, "DIS_SIGNAL3", &dis_signal3) == ED247_STATUS_SUCCESS);

  // =========================================================================
  // Demo 1 - Simple API: stream assistant and automatic push/pop written signals
  LOG("------ [ DEMO 1 ] -------");

  // The ed247_stream_push_sample() method expect you to push the whole stream, not a specific signal.
  // You could manually write the stream payload and push it, but this is not handy.
  // The ED247 library provide you a tool to perform that job: the stream assistant.

  // The stream assistant allow you to read and write a signal from a stream, without knowing
  // how they are encoded in the stream: it handle byte offsets and endianness for you.
  // (endianness handling is required for analogue, NAD and VNAD)

  // Get all assistant associated to our signals.
  ed247_stream_assistant_t dis_signal1_assistant;
  ed247_stream_assistant_t dis_signal2_assistant;
  ed247_stream_assistant_t dis_signal3_assistant;
  ASSERT(ed247_signal_get_assistant(dis_signal1, &dis_signal1_assistant) == ED247_STATUS_SUCCESS);
  ASSERT(ed247_signal_get_assistant(dis_signal2, &dis_signal2_assistant) == ED247_STATUS_SUCCESS);
  ASSERT(ed247_signal_get_assistant(dis_signal3, &dis_signal3_assistant) == ED247_STATUS_SUCCESS);

  // A stream assistant is associated to a stream, not a signal. In the ECIC, only two streams are
  // defined, so it will be only two stream assistants. The code upside will return the same object
  // for dis_signal1 assistant and dis_signal2 assistant. *This is the expected usage*.
  // The signal based streams shall have been generated by the resolving process and not defined by
  // the EC. So, when we write the EC code, we don't know which stream will be present and we don't
  // know which signal will be in which stream.
  // The ED247 Library allows to write an EC while completely ignoring this information.

  // Write data to some of our signals
  ASSERT(ed247_stream_assistant_write_signal(dis_signal1_assistant, dis_signal1, &dis_true, 1) == ED247_STATUS_SUCCESS);
  ASSERT(ed247_stream_assistant_write_signal(dis_signal3_assistant, dis_signal3, &dis_false, 1) == ED247_STATUS_SUCCESS);
  SAY("Discrete signal 1 and 3 wrote.");

  // Push all streams whose signals have bee written
  // In our case, dis_signal1 and dis_signal3 has been written. dis_signal1 is part of stream1 and
  // dis_signal3 is part of stream2. So these both streams will be pushed.
  // dis_signal2 has not be written and it is also part of stream1. The ED247 protocol do not
  // allows partial signal streams, so dis_signal2 will also be pushed. The ED247 library guaranty
  // the signal default value to be 0.
  ASSERT(ed247_stream_assistants_written_push_samples(ed247_context, nullptr) == ED247_STATUS_SUCCESS);
  SAY("Stream 1 and Stream 2 wrote.");

  // ed247_stream_assistants_written_push_samples() will only push written signals since last call,
  // so it's safe to call it after each write(). (at a little CPU cost since the library will check which
  // stream has been written)
  // In this case, we don't have written any new signal, this call will do nothing.
  ASSERT(ed247_stream_assistants_written_push_samples(ed247_context, nullptr) == ED247_STATUS_SUCCESS);

  // Send our signals
  ASSERT(ed247_send_pushed_samples(ed247_context) == ED247_STATUS_SUCCESS);
  SAY("Data #1 sent.");

  SYNC_WAIT(ed247_context, 1);


  // =========================================================================
  // Demo 2 - Signal values are preserved
  LOG("------ [ DEMO 2 ] -------");

  // We only write dis_signal2
  ASSERT(ed247_stream_assistant_write_signal(dis_signal2_assistant, dis_signal2, &dis_true, 1) == ED247_STATUS_SUCCESS);

  // Only dis_signal2 has be written so only stream1 will be pushed.
  // But this stream also contain dis_signal1. Its last written value (dis_true) will be preserved.
  ASSERT(ed247_stream_assistants_written_push_samples(ed247_context, nullptr) == ED247_STATUS_SUCCESS);

  // Send our signals
  ASSERT(ed247_send_pushed_samples(ed247_context) == ED247_STATUS_SUCCESS);
  SAY("Data #2 sent.");

  SYNC_WAIT(ed247_context, 2);


  // =========================================================================
  // Demo 3 - manual stream assistant push/pop, setting different data timestamp
  LOG("------ [ DEMO 3 ] -------");

  // Write some data
  ASSERT(ed247_stream_assistant_write_signal(dis_signal1_assistant, dis_signal1, &dis_true, 1) == ED247_STATUS_SUCCESS);
  ASSERT(ed247_stream_assistant_write_signal(dis_signal2_assistant, dis_signal2, &dis_true, 1) == ED247_STATUS_SUCCESS);
  ASSERT(ed247_stream_assistant_write_signal(dis_signal3_assistant, dis_signal3, &dis_false, 1) == ED247_STATUS_SUCCESS);
  SAY("Discrete signal 1 and 3 wrote.");

  // To set different data timestamp on each stream, we need to push() each stream assistant ourselves.
  // (we also can call ed247_stream_assistants_written_push_samples() after each write but this is not optimal...)

  // Arbitrary data timestamps (aka acquisition timestamp)
  ed247_timestamp_t dis_signal1_dts = { 10, 0 };
  ed247_timestamp_t dis_signal2_dts = { 11, 0 };
  ed247_timestamp_t dis_signal3_dts = { 12, 0 };

  // We want to push each assistants only once, so we store already pushed assistant
  // Remember: the resolving process has generated the streams. We don't know how many different assistants we have.
  std::unordered_set<ed247_stream_assistant_t> pushed_assistants;

  // Push only once each assistant
  if (pushed_assistants.find(dis_signal1_assistant) == pushed_assistants.end()) {
    ASSERT(ed247_stream_assistant_push_sample(dis_signal1_assistant, &dis_signal1_dts, nullptr) == ED247_STATUS_SUCCESS);
    pushed_assistants.insert(dis_signal1_assistant);
    SAY("Stream assistant of dis_signal1 has been pushed.");
  }
  if (pushed_assistants.find(dis_signal2_assistant) == pushed_assistants.end()) {
    ASSERT(ed247_stream_assistant_push_sample(dis_signal2_assistant, &dis_signal2_dts, nullptr) == ED247_STATUS_SUCCESS);
    pushed_assistants.insert(dis_signal2_assistant);
    SAY("Stream assistant of dis_signal2 has been pushed.");
  }
  if (pushed_assistants.find(dis_signal3_assistant) == pushed_assistants.end()) {
    ASSERT(ed247_stream_assistant_push_sample(dis_signal3_assistant, &dis_signal3_dts, nullptr) == ED247_STATUS_SUCCESS);
    pushed_assistants.insert(dis_signal3_assistant);
    SAY("Stream assistant of dis_signal3 has been pushed.");
  }

  // *WARNING*: The data timestamp is associated with the stream. So all signals of a stream
  // will share the same data timestamp. In this sample, dis_signal2 will be dated with
  // dis_signal1_dts and NOT with dis_signal2_dts. (dis_signal1_assistant and dis_signal2_assistant
  // are the same object, so the 'second if' is skipped)
  // To tackle that, a stream shall contain only signal that are acquired at the same period. This
  // is handled by the resolving process througth the pool concept. See resolver sample for more details.


  // Send our signals
  ASSERT(ed247_send_pushed_samples(ed247_context) == ED247_STATUS_SUCCESS);
  SAY("Data #3 sent.");


  ed247_unload(ed247_context);
  return 0;
}
